generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Role {
  OWNER
  ADMIN
  MEMBER
}

enum PlanType {
  STARTER
  PRO
}

model Subscription {
  id                   String    @id @default(uuid()) @db.Uuid
  userId               String    @unique @map("user_id")
  stripeCustomerId     String    @unique @map("stripe_customer_id")
  stripeSubscriptionId String?   @unique @map("stripe_subscription_id")
  status               String    @map("status")
  plan                 PlanType  @default(STARTER) @map("plan")
  currentPeriodEnd     DateTime? @map("current_period_end")
  /// When set, subscription is scheduled to end at this time (cancel_at or period end if cancel_at_period_end).
  cancelAt             DateTime? @map("cancel_at")

  organizations Organization[]

  @@map("subscriptions")
}

model Organization {
  id        String   @id @default(uuid()) @db.Uuid
  name      String

  /// Optional webhook URLs for notifications (Slack, Discord).
  slackWebhookUrl   String? @map("slack_webhook_url")
  discordWebhookUrl String? @map("discord_webhook_url")
  /// JSON flags: { "anomaly": true, "dailySummary": false }
  notificationSettings Json? @map("notification_settings")

  subscriptionId String?  @db.Uuid @map("subscription_id")
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  profiles        Profile[]
  cloudAccounts   CloudAccount[]
  dailySpends     DailySpend[]
  organizationInvites OrganizationInvite[]

  @@map("organizations")
}

model Profile {
  id String @id @default(uuid()) @db.Uuid

  /// Supabase auth user id (UUID) from auth.users
  userId String @db.Uuid @map("user_id")

  organizationId String        @db.Uuid @map("organization_id")
  organization   Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  role Role @default(MEMBER)

  firstName  String? @map("first_name")
  lastName   String? @map("last_name")
  avatarPath String? @map("avatar_path")

  theme  String? @default("system")
  locale String? @default("pt")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([userId, organizationId], name: "profile_user_org_unique")
  @@map("profiles")
}

enum CloudProvider {
  AWS
  VERCEL
  GCP
  OTHER
}

enum CloudAccountStatus {
  SYNCED
  SYNCING
  SYNC_ERROR
}

model CloudAccount {
  id String @id @default(uuid()) @db.Uuid

  organizationId String       @db.Uuid @map("organization_id")
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  dailySpends DailySpend[]

  provider CloudProvider

  /// Human readable name for this account (e.g. "Prod AWS")
  label String

  /// Encrypted credentials payload (AES-256-GCM).
  /// Stored as serialized string: iv:authTag:ciphertext
  encryptedCredentials String @map("encrypted_credentials")

  /// Optional metadata (e.g. account id, region) as JSON.
  metadata Json?

  /// Sync status: SYNCED (ok), SYNCING (in progress), SYNC_ERROR (last sync failed).
  status CloudAccountStatus @default(SYNCED) @map("status")

  /// Error message when status is SYNC_ERROR (e.g. from last sync attempt).
  lastSyncError String? @map("last_sync_error")

  /// Last time a sync completed successfully for this account.
  lastSyncedAt DateTime? @map("last_synced_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([organizationId], name: "cloud_account_org_idx")
  @@map("cloud_accounts")
}

model DailySpend {
  id String @id @default(uuid()) @db.Uuid

  organizationId String       @db.Uuid @map("organization_id")
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  cloudAccountId String      @db.Uuid @map("cloud_account_id")
  cloudAccount   CloudAccount @relation(fields: [cloudAccountId], references: [id], onDelete: Cascade)

  /// Date of the spend (UTC date, no time component).
  date DateTime @map("date")

  /// Cloud provider that generated this spend (normalized).
  provider CloudProvider

  /// Service name (e.g. "Lambda", "S3", "Edge Functions").
  serviceName String @map("service_name")

  /// Amount in cents (integer) to avoid floating point drift.
  amountCents Int @map("amount_cents")

  /// Optional currency code (e.g. "USD").
  currency String? @default("USD")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  /// Composite unique index to guarantee idempotent syncs per account.
  @@unique([organizationId, cloudAccountId, provider, serviceName, date], name: "daily_spend_org_provider_service_date_account_unique")

  @@index([organizationId, date], name: "daily_spend_org_date_idx")
  @@map("daily_spend")
}

model OrganizationInvite {
  id String @id @default(uuid()) @db.Uuid

  email String

  organizationId String       @db.Uuid @map("organization_id")
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  role Role

  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")

  @@unique([organizationId, email], name: "org_invite_org_email_unique")
  @@map("organization_invites")
}
